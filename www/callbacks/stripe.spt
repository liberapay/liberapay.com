from datetime import timedelta

import stripe

from liberapay.exceptions import DuplicateNotification
from liberapay.models.participant import Participant
from liberapay.payin.common import update_payin_transfer
from liberapay.payin.stripe import (
    int_to_Money, Money_to_int, record_reversals, repr_charge_error, settle_charge
)
from liberapay.utils import utcnow

SIX_HOURS = timedelta(hours=6)
PRODUCTION = website.env.instance_type == 'production'

[---]

request.allow('POST')
payload = request.body_bytes
sig = request.headers[b'Stripe-Signature'].decode('ascii', 'replace')
try:
    event = stripe.Webhook.construct_event(
        payload, sig, website.app_conf.stripe_callback_secret
    )
except ValueError as e:
    raise response.error(400, str(e))
except stripe.error.SignatureVerificationError:
    raise response.error(403, "invalid signature")

if event.livemode != PRODUCTION:
    raise response.error(400, "environment mismatch")

event_object_type, status = event.type.rsplit('.', 1)

if event_object_type == 'charge':
    charge = event.data.object
    payin_id = charge.metadata['payin_id']
    payin = website.db.one("""
        SELECT *
          FROM payins
         WHERE id = %s
    """, (payin_id,))
    assert payin
    if payin.ctime > (utcnow() - timedelta(seconds=60)):
        raise response.error(409, "This callback is too early.")
    payin = settle_charge(website.db, payin, charge)
    if status in ('failed', 'succeeded') and payin.ctime < (utcnow() - SIX_HOURS):
        payer = Participant.from_id(payin.payer)
        payer.notify('payin_' + payin.status, payin=payin._asdict(), provider='Stripe')

elif event_object_type == 'charge.dispute':
    dispute = event.data.object
    charge = stripe.Charge.retrieve(dispute.charge)
    payin_id = charge.metadata['payin_id']
    payin = website.db.one("SELECT * FROM payins WHERE id = %s", (payin_id,))
    route = website.db.one("SELECT r FROM exchange_routes r WHERE id = %s", (payin.route,))
    if route.status != 'canceled':
        route.invalidate()
    payin = settle_charge(website.db, payin, charge)
    if dispute.status == 'lost':
        if dispute.amount != charge.amount:
            raise NotImplementedError("partial chargebacks aren't implemented")
        transfers = website.db.all("""
            SELECT pt.*
              FROM payin_transfers pt
             WHERE pt.payin = %s
               AND pt.status = 'succeeded'
               AND coalesce(pt.reversed_amount < pt.amount, true)
        """, (payin.id,))
        for pt in transfers:
            if pt.remote_id:
                reversal_amount = pt.amount - (pt.reversed_amount or 0)
                if reversal_amount:
                    stripe.Transfer.create_reversal(
                        pt.remote_id,
                        amount=Money_to_int(reversal_amount),
                        idempotency_key='%s_pt_%i' % (dispute.id, pt.id),
                    )
                    # â†‘ This triggers a `transfer.reversed` event, handled below.
            else:
                update_payin_transfer(
                    website.db, pt.id, None, pt.status, pt.error,
                    reversed_amount=pt.amount,
                )
    # Notify the person who initiated the payment
    payer = Participant.from_id(payin.payer)
    if dispute.status in ('needs_response', 'lost'):
        try:
            payer.notify(
                'payin_disputed',
                email_unverified_address=True,
                force_email=True,
                idem_key=dispute.id,
                payin_id=payin.id,
                payin_amount=payin.amount,
                payin_ctime=payin.ctime,
                dispute_reason=dispute.reason,
                dispute_can_be_withdrawn=dispute.status == 'needs_response',
            )
        except DuplicateNotification:
            pass
    else:
        raise NotImplementedError(dispute.status)

elif event.type == 'transfer.reversed':
    transfer = event.data.object
    pt_id = transfer.metadata.get('payin_transfer_id')
    if pt_id:
        pt = website.db.one("SELECT * FROM payin_transfers WHERE id = %s", (pt_id,))
    else:
        charge = stripe.Charge.retrieve(transfer.source_transaction)
        payin_id = charge.metadata['payin_id']
        pt = website.db.one("""
            SELECT *
              FROM payin_transfers
             WHERE payin = %s
               AND remote_id = %s
        """, (payin_id, transfer.id))
    assert pt
    record_reversals(website.db, pt, transfer)
    fee = transfer.amount - Money_to_int(pt.amount)
    reversed_amount = transfer.amount_reversed - fee
    if reversed_amount:
        update_payin_transfer(
            website.db, pt.id, None, pt.status, pt.error,
            reversed_amount=int_to_Money(reversed_amount, transfer.currency),
        )

elif event.type == 'account.updated':
    account = event.data.object
    website.db.run("""
        UPDATE payment_accounts
           SET country = %(country)s
             , default_currency = %(default_currency)s
             , charges_enabled = %(charges_enabled)s
             , display_name = %(display_name)s
         WHERE id = %(account_id)s
    """, dict(
        country=account.country,
        default_currency=account.default_currency.upper(),
        charges_enabled=account.charges_enabled,
        display_name=account.settings.dashboard.display_name,
        account_id=account_id,
    ))

else:
    raise response.error(500, "unknown event object type %r" % event_object_type)

[---] text/plain
OK
